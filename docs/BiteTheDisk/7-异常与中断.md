# 异常与中断

在操作系统中，异常和中断是控制和调度用户程序以及外设硬件的关键方式。对于 RISCV 架构而言，中断向量会存储在 stvec 寄存器中。

在 RV64 中， `stvec` 是一个 64 位的 CSR，在中断使能的情况下，保存了中断处理的入口地址。它有两个字段：

- MODE 位于 [1:0]，长度为 2 bits；
- BASE 位于 [63:2]，长度为 62 bits。

当 MODE 字段为 0 的时候， `stvec` 被设置为 Direct 模式，此时进入 S 模式的 Trap 无论原因如何，处理 Trap 的入口地址都是 `BASE<<2` ， CPU 会跳转到这个地方进行异常处理。

BTD-OS 将 `stvec` 设置为 Direct 模式，当发生异常或中断时，pc 寄存器会被设置为 stvec 中存储的中断向量的值。因此，我们需要为内核编写异常或中断处理函数，并将其地址存储到 stvec 寄存器中。这样，当系统遇到异常或中断时，将会跳转到所存储的地址执行相应的处理代码。

### 返回用户态

目前 BTD-OS 中有两种情况会执行返回用户态流程：

- 进程通过解析 elf 文件从内核态创建后，需要返回用户态去执行 elf 文件中的代码；
- 进程因为异常或者中断陷入内核之后，需要重新返回用户态。

在 trampoline.S 中，汇编函数 \_\_user\_\_trapret，手动保存所有的 caller-saved 寄存器，并恢复用户态的所有通用寄存器，并将 TrapContext 结构体的地址保存在 sscratch 寄存器中。

此外，当一个进程刚刚创建时，我们需要为其内核态和用户态设置初始值。对于用户态的 32 个通用寄存器，默认情况下会被赋值为 0，但是 sp 寄存器的值需要根据我们设定的用户态栈 (USER_STACK_BASE) 进行赋值。

### 陷入内核态

当用户因系统调用、时钟中断、缺页中断等原因发生异常和中断时，往往会触发 RISC-V 特权级切换。

当 CPU 执行完一条指令（如 ecall ）并准备从用户特权级 陷入（ Trap ）到 S 特权级的时候，硬件会自动完成如下这些事情：

- sstatus 的 SPP 字段会被修改为 CPU 当前的特权级（U/S）；
- sepc 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址；
- scause/stval 分别会被修改成这次 Trap 的原因以及相关的附加信息；
- CPU 会跳转到 stvec 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行；

在 Trap 触发的一瞬间， CPU 就会切换到 S 特权级并跳转到 stvec 所指示的位置。但是在正式进入 S 特权级的 Trap 处理之前，为了能够在返回用户态时恢复现场，我们需要保存用户态的上下文，其中包括 32 个通用寄存器和 sepc 寄存器。通过保存通用寄存器的值，我们可以恢复用户态的执行状态，而 sepc 寄存器则允许用户态在发生异常的指令处或下一条指令处继续执行。

为了在中断向量中保存这些寄存器的值，我们需要一个内核结构体来存储这些信息，因为此时已经处于内核态。为了知道该内核结构体的地址，在陷入内核时我们需要获取该地址。在 RISC-V 架构中，特权寄存器 sscratch 可以用来存放与核心相关的上下文地址。当我们返回用户态时，会将 TrapContext 结构体的地址存入 sscratch 寄存器中，因此可以利用该寄存器来保存用户的上下文信息。